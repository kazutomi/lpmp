#!/usr/bin/env ruby
# coding: utf-8

case ENV['LANG']
when /\Aja_/
  FigureFormat = "図%s　"
  CodeListFormat = "リスト%s　"
else
  FigureFormat = "Figure %s: "
  CodeListFormat = "List %s: "
end

class LpmpState
  DefaultSectionDepth = 5
  attr_accessor :file_name, :matter, :secno, :figno, :listno, :verb
  attr_reader :secdepth

  def initialize(sec_depth = DefaultSectionDepth)
    @file_name = nil
    @matter = :main
    @secdepth = sec_depth
    reset_sections
    @figno = 0
    @listno = 0
    @verb = false
  end

  def reset_sections
    @secno = Array.new(@secdepth, 0)
  end
end

class InputLine
  attr_accessor :line, :no

  def initialize(line, no)
    @line = line
    @no = no
  end
end

$state = nil
$figtag = {}
$listtag = {}

NPass = 2  # two-pass processing

def process_kw(l)
  l.line.gsub!(/@<kw>{([^,}]+)(,[^}]+)?}/){"**#{$1}**"}  # ignore yomi for now
  l
end

def process_ruby(l)
  l.line.gsub!(/@<ruby>{([^,]+),([^}]+)}/){"#{$1}^#{$2}^"}
  l
end

def process_commands(l)
  if /^@@/ =~ l.line
    # reserved for line directive
    l = nil
  else
    l = process_kw(l)
    l = process_ruby(l) unless l.nil?
  end
  l
end

def switch_matter(l)
  case l.line
  when '{frontmatter}'
    $state.matter = :front
    $state.reset_sections
  when '{mainmatter}'
    $state.matter = :main
    $state.reset_sections
  when '{backmatter}'
    $state.matter = :back
    $state.reset_sections
  else
  end
  l
end

def number_sections(l)
  return l unless l.line.start_with?('#')
  depth = nil
  $state.secdepth.downto(1) do |i|
    if l.line.start_with?('#'*i)
      depth = i
      break
    end
  end
  depth -= 1  # 0-origin

  $state.secno[depth] += 1
  if depth < $state.secdepth
    for i in (depth+1)..$state.secdepth do
      $state.secno[i] = 0
    end
  end

  $state.figno = 0 if depth == 0

  tag = case $state.matter
        when :front
          '#front'
        when :main
          '#section'
        when :back
          '#back'
        end
  for i in 0..depth do
    tag += "-#{$state.secno[i]}"
  end

  l.line += " {#{tag}}"
  l
end

def number_figures(l)
  l.line.scan(/^@<fig>\{([^}]*)\}\[([^\]]*)\]\(([^)]*)\)/) do
    $state.figno += 1
    $figtag[$1] = "#{$state.secno[0]}-#{$state.figno}"
  end
  l
end

def number_code_lists(l)
  case l.line
  when /^@<list>\{([^}]*)\}/
    $state.listno += 1
    $listtag[$1] = "#{$state.secno[0]}-#{$state.listno}"
  end
  l
end

def figure_format(no)
  sprintf FigureFormat, no
end

def code_list_format(no)
  sprintf CodeListFormat, no
end

def tag_figures(l)
  l.line.sub!(/^@<fig>\{([^}]*)\}\[([^\]]*)\]\(([^)]*)\)/) do
    tag = $1
    figno = $figtag[tag] || 'XX'
    caption = $2
    file = $3
    "{#{tag}}\n![#{figure_format(figno)}#{caption}](#{file})"
  end
  l
end

def tag_code_lists(l)
  l.line.sub!(/^@<list>\{([^}]*)\}\[([^\]]*)\]\(([^)]*)\)/) do
    tag = $1
    listno = $listtag[tag] || 'XX'
    caption = $2
    file = $3
    "{#{tag}}\n" +
    "[#{code_list_format(listno)}#{caption}](#{file})\n"
  end
  l.line.sub!(/^@<list>\{([^}]*)\}\[([^\]]*)\]/) do
    tag = $1
    listno = $listtag[tag] || 'XX'
    caption = $2
    "{#{tag}}\n" +
    "{title=\"#{code_list_format(listno)}#{caption}\"}\n" +
    "~~~~~~~~\n"
  end
  l.line.sub!(/^@<list>$/) do
    "~~~~~~~~\n"
  end
  l
end

def reference_figures(l)
  l.line.gsub!(/@<fig>\(([^)]*)\)/) do
    figno = ''
    tag = $1
    if $figtag.key?(tag)
      figno = "[#{$figtag[tag]}](#{tag})"
    else
      $stderr.puts "#{$state.file_name}:#{l.no}: warning: undefined figure tag #{tag}"
      figno = 'XX'
    end
    figno
  end
  l
end

def reference_code_lists(l)
  l.line.gsub!(/@<list>\(([^)]*)\)/) do
    listno = ''
    tag = $1
    if $listtag.key?(tag)
      listno = "[#{$listtag[tag]}](#{tag})"
    else
      $stderr.puts "#{$state.file_name}:#{l.no}: warning: undefined list tag #{tag}"
      listno = 'XX'
    end
    listno
  end
  l
end

def switch_verb(l)
  if $state.verb
    if $state.verb == l.line
      $state.verb = false
    end
  else
    case l.line
    when /\A~+\Z/
      $state.verb = l.line
    when /\A@<list>\{[^}]+\}\[[^\]]+\]\s*\Z/
      $state.verb = '@<list>'
    end
  end
  l
end

def process_file(in_lines, pass)
  out_lines = []

  case pass
  when 0  # number sections and figures
    in_lines.each do |l|
      l = number_code_lists(l)
      l = switch_verb(l) unless l.nil?
      unless $state.verb
        l = switch_matter(l) unless l.nil?
        l = number_sections(l) unless l.nil?
        l = number_figures(l) unless l.nil?
      end
      out_lines << l unless l.nil?
    end
  when 1  # process Re:VIEW-like commands
    in_lines.each do |l|
      l = tag_code_lists(l)
      l = switch_verb(l) unless l.nil?
      unless $state.verb
        l = tag_figures(l) unless l.nil?
        l = reference_figures(l) unless l.nil?
        l = reference_code_lists(l) unless l.nil?
        l = process_commands(l) unless l.nil?
      end
      out_lines << l unless l.nil?
    end
  else
    $stderr.puts "Unexpected pass #{npass}"
    out_lines = in_lines
  end

  out_lines
end

def main
  $state = LpmpState.new

  txtfiles = []
  open('Book.txt') do |f|
    f.each_line do |l|
      txtfiles << l.chomp
    end
  end

  files_lines = []
  txtfiles.each do |txtf|
    if File.extname(txtf) != '.txt'
      $stderr.puts "Book.txt entry \"#{txtf}\" is not .txt; skipping"
      next
    end
    lines = []
    lmpf = txtf.sub(/\.txt$/, '.lmp')
    $state.file_name = lmpf
    open(lmpf) do |f|
      line_no = 0
      f.each_line do |l|
        line_no += 1
        lines << InputLine.new(l.chomp, line_no)
      end
    end
    files_lines << lines
  end

  NPass.times do |npass|
    $state.verb = false
    files_lines.size.times do |i|
      files_lines[i] = process_file(files_lines[i], npass)
    end
  end

  [txtfiles, files_lines].transpose.each do |txtf, lines|
    open(txtf, 'w') do |f|
      lines.each do |l|
        f.puts l.line
      end
    end
  end
end

main
0
