#!/usr/bin/env ruby
# coding: utf-8

case ENV['LANG']
when /\Aja_/
  FigureFormat = "図%s　"
  CodeListFormat = "リスト%s　"
else
  FigureFormat = "Figure %s: "
  CodeListFormat = "List %s: "
end

class LpmpState
  DefaultSectionDepth = 5
  attr_accessor :file_name, :matter, :secno, :figno, :listno, :verb
  attr_reader :secdepth

  def initialize(sec_depth = DefaultSectionDepth)
    @file_name = nil
    @matter = :main
    @secdepth = sec_depth
    reset_sections
    @figno = 0
    @listno = 0
    @verb = false
  end

  def reset_sections
    @secno = Array.new(@secdepth, 0)
  end
end

class LineStream
  class InputLine
    attr_accessor :line, :no

    def initialize(line, no)
      @line = line
      @no = no
    end
  end

  attr_accessor :queue  # of InputLines

  def initialize(lines = [])
    @queue = []
    n = 0
    lines.each do |s|
      n += 1
      @queue << InputLine.new(s, n)
    end
  end

  def empty?
    @queue.size == 0
  end

  def getl
    @queue.shift
  end

  def putl(l)
    @queue << l
  end

  def unshift(x)
    #puts "Unshifting #{x.inspect} to #{@queue}"
    case x
    when Array, InputLine
      @queue.unshift(*x)
    when nil
    else
      $stderr.puts "Error: cannot unshift #{x} to LineStream"
    end
    #puts "Unshift done #{@queue}"
  end

  def each
    @queue.each do |l|
      yield l
    end
  end

  def dump
    puts "*** Dumping LineStream ***"
    @queue.each do |l|
      puts "#{l.inspect}"
    end
    puts "*** End Dumping ***"
  end
end

$state = nil
$figtag = {}
$listtag = {}

NPass = 2  # two-pass processing

def process_kw(l)
  l.line.gsub!(/@<kw>{([^,}]+)(,[^}]+)?}/){"**#{$1}**"}  # ignore yomi for now
  l
end

def process_ruby(l)
  l.line.gsub!(/@<ruby>{([^,]+),([^}]+)}/){"#{$1}^#{$2}^"}
  l
end

def process_commands(l)
  if /^@@/ =~ l.line
    # reserved for line directive
    l = nil
  else
    l = process_kw(l)
    l = process_ruby(l) unless l.nil?
  end
  l
end

def switch_matter(l)
  case l.line
  when '{frontmatter}'
    $state.matter = :front
    $state.reset_sections
  when '{mainmatter}'
    $state.matter = :main
    $state.reset_sections
  when '{backmatter}'
    $state.matter = :back
    $state.reset_sections
  else
  end
  l
end

def number_sections(l)
  return l unless l.line.start_with?('#')
  depth = nil
  $state.secdepth.downto(1) do |i|
    if l.line.start_with?('#'*i)
      depth = i
      break
    end
  end
  depth -= 1  # 0-origin

  $state.secno[depth] += 1
  if depth < $state.secdepth
    for i in (depth+1)..$state.secdepth do
      $state.secno[i] = 0
    end
  end

  $state.figno = 0 if depth == 0

  tag = case $state.matter
        when :front
          '#front'
        when :main
          '#section'
        when :back
          '#back'
        end
  for i in 0..depth do
    tag += "-#{$state.secno[i]}"
  end

  l.line += " {#{tag}}"
  l
end

def number_figures(l)
  l.line.scan(/^@<fig>\{([^}]*)\}\[([^\]]*)\]\(([^)]*)\)/) do
    $state.figno += 1
    $figtag[$1] = "#{$state.secno[0]}-#{$state.figno}"
  end
  l
end

def number_code_lists(l)
  case l.line
  when /^@<list>\{([^}]*)\}/
    $state.listno += 1
    $listtag[$1] = "#{$state.secno[0]}-#{$state.listno}"
  end
  l
end

def figure_format(no)
  sprintf FigureFormat, no
end

def code_list_format(no)
  sprintf CodeListFormat, no
end

def tag_figures(l)
  if /\A@<fig>\{([^}]*)\}\[([^\]]*)\]\(([^)]*)\)\s*\Z/ =~ l.line
    tag = $1
    figno = $figtag[tag] || 'XX'
    caption = $2
    file = $3
    [
      LineStream::InputLine.new("{##{tag}}", l.no),
      LineStream::InputLine.new(
        "![#{figure_format(figno)}#{caption}](#{file})",
        l.no
      ),
    ]
  else
    l
  end
end

def tag_code_lists(l)
  case l.line
  when /\A@<list>\{([^}]*)\}\[([^\]]*)\]\(([^)]*)\)\s*\Z/
    tag = $1
    listno = $listtag[tag] || 'XX'
    caption = $2
    file = $3
    [
      LineStream::InputLine.new("{##{tag}}", l.no),
      LineStream::InputLine.new(
        "[#{code_list_format(listno)}#{caption}](#{file})",
        l.no
      ),
    ]
  when /\A@<list>\{([^}]*)\}\[([^\]]*)\]\s*\Z/
    tag = $1
    listno = $listtag[tag] || 'XX'
    caption = $2
    [
      LineStream::InputLine.new(
        "{id=\"#{tag}\", title=\"#{code_list_format(listno)}#{caption}\"}",
        l.no
      ),
      LineStream::InputLine.new('~~~~~~~~', l.no),
    ]
  when /\A@<list>\s*\Z/
    '~~~~~~~~'
  end
end

def reference_figures(l)
  l.line.gsub!(/@<fig>\(([^)]*)\)/) do
    figno = ''
    tag = $1
    if $figtag.key?(tag)
      figno = "[#{$figtag[tag]}](##{tag})"
    else
      $stderr.puts "#{$state.file_name}:#{l.no}: warning: undefined figure tag #{tag}"
      figno = 'XX'
    end
    figno
  end
  l
end

def reference_code_lists(l)
  l.line.gsub!(/@<list>\(([^)]*)\)/) do
    listno = ''
    tag = $1
    if $listtag.key?(tag)
      listno = "[#{$listtag[tag]}](##{tag})"
    else
      $stderr.puts "#{$state.file_name}:#{l.no}: warning: undefined list tag #{tag}"
      listno = 'XX'
    end
    listno
  end
  l
end

def switch_verb(l)
  if $state.verb
    if $state.verb == l.line
      $state.verb = false
    end
  else
    case l.line
    when /\A~+\Z/
      $state.verb = l.line
    when /\A@<list>\{[^}]+\}\[[^\]]+\]\s*\Z/
      $state.verb = '@<list>'
    end
  end
  l
end

def process_file(in_lines, pass)
  out_lines = LineStream.new

  case pass
  when 0  # number sections and figures
    while not in_lines.empty?
      in_lines.unshift(number_code_lists(in_lines.getl))
      in_lines.unshift(switch_verb(in_lines.getl))
      unless $state.verb
        in_lines.unshift(switch_matter(in_lines.getl))
        in_lines.unshift(number_sections(in_lines.getl))
        in_lines.unshift(number_figures(in_lines.getl))
      end
      if (l = in_lines.getl)
        out_lines.putl(l)
      end
    end
  when 1
    while not in_lines.empty?
      in_lines.unshift(tag_code_lists(in_lines.getl))
      in_lines.unshift(switch_verb(in_lines.getl))
      unless $state.verb
        in_lines.unshift(tag_figures(in_lines.getl))
        in_lines.unshift(reference_figures(in_lines.getl))
        in_lines.unshift(reference_code_lists(in_lines.getl))
        in_lines.unshift(process_commands(in_lines.getl))
      end
      if (l = in_lines.getl)
        out_lines.putl(l)
      end
    end
  else
    $stderr.puts "Unexpected pass #{npass}"
    out_lines = in_lines
  end

  out_lines
end

def main
  $state = LpmpState.new

  txtfiles = []
  open('Book.txt') do |f|
    f.each_line do |l|
      txtfiles << l.chomp
    end
  end

  files_lines = []
  txtfiles.each do |txtf|
    if File.extname(txtf) != '.txt'
      $stderr.puts "Book.txt entry \"#{txtf}\" is not .txt; skipping"
      next
    end
    lmpf = txtf.sub(/\.txt$/, '.lmp')
    $state.file_name = lmpf
    lines = nil
    open(lmpf) do |f|
      lines = LineStream.new(f.readlines.map {|l| l.chomp})
    end
    files_lines << lines
  end

  NPass.times do |npass|
    $state.verb = false
    files_lines.size.times do |i|
      #puts "%%% before pass #{npass}, file #{i}"
      #files_lines[i].dump
      files_lines[i] = process_file(files_lines[i], npass)
      #puts "%%% after pass #{npass}, file #{i}"
      #files_lines[i].dump
    end
  end

  [txtfiles, files_lines].transpose.each do |txtf, lines|
    open(txtf, 'w') do |f|
      lines.each do |l|
        f.puts l.line
      end
    end
  end
end

main
0
