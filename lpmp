#!/usr/bin/env ruby
# coding: utf-8

class LpmpState
  DefaultSectionDepth = 5
  attr_accessor :matter, :secno
  attr_reader :secdepth

  def initialize(sec_depth = DefaultSectionDepth)
    @matter = :main
    @secno = Array.new(sec_depth, 0)
    @secdepth = sec_depth
  end
end

$state = nil

NPass = 2  # two-pass processing

def process_kw(l)
  l.gsub(/@<kw>{([^,}]+)(,[^}]+)?}/){"**#{$1}**"}  # ignore yomi for now
end

def process_ruby(l)
  l.gsub(/@<ruby>{([^,]+),([^}]+)}/){"#{$1}^#{$2}^"}
end

def process(l)
  s = nil
  if /^@@/ =~ l
    # reserved for line directive
    s = nil
  else
    s = process_kw(l)
    s = process_ruby(s) unless s.nil?
  end
  s
end

def number_sections(s)
  return s unless s.start_with?('#')
  depth = nil
  $state.secdepth.downto(1) do |i|
    if s.start_with?('#'*i)
      depth = i
      break
    end
  end
  depth -= 1  # 0-origin

  $state.secno[depth] += 1
  if depth < $state.secdepth
    for i in (depth+1)..$state.secdepth do
      $state.secno[i] = 0
    end
  end

  tag = '#section'
  for i in 0..depth do
    tag += "-#{$state.secno[i]}"
  end

  s += " {#{tag}}"
  s
end

def number_figures(s)
  s
end

def main
  in_lines = ARGF.readlines.map {|s| s.chomp}
  out_lines = nil

  NPass.times do |npass|
    case npass
    when 0  # number sections and figures
      out_lines = []
      $state = LpmpState.new
      in_lines.each do |l|
        s = number_sections(l)
        s = number_figures(s) unless s.nil?
        out_lines << s unless s.nil?
      end
    when 1  # process Re:VIEW-like commands
      out_lines = []
      in_lines.each do |l|
        s = process(l)
        out_lines << s unless s.nil?
      end
    else
      $stderr.puts "Unexpected pass #{npass}"
      out_lines = in_lines
    end
    in_lines = out_lines
  end

  in_lines.each do |l|
    puts l
  end
end

main
0
